#01 Introduction to TypeScript

ğŸ”· What is TypeScript?
##########################

â¤TypeScript is a superset of JavaScript.
â¤It is a programming language built on JavaScript.
â¤TypeScript has all the features of JavaScript plus extra features like:
1. interface
2. access modifiers

These features are not available in the latest version of JavaScript.

ğŸ¯ Why Use TypeScript?
â¤TypeScript makes writing JavaScript easier, cleaner, less error-prone.
â¤You can write simple code in TypeScript which compiles to complex JavaScript logic.
â¤Helps avoid bugs and identity

âš ï¸ Limitation of TypeScript
â¤TypeScript code cannot be executed directly by JavaScript runtimes like:
1. Browser
2. Node.js

âš™ï¸ How TypeScript Works
â¤TypeScript is also a tool â€” a powerful compiler.
â¤It compiles TypeScript code into JavaScript code.
â¤Then this JavaScript code can be run by:
1. Browser
2. Node.js

â¤We donâ€™t write JavaScript directly when using TypeScript.
â¤We write TypeScript, then compile it to JavaScript.

ğŸ¤” How can TS use new features if JS doesnâ€™t support them?
â¤The TypeScript compiler uses workarounds in JavaScript.
â¤TS features are compiled into equivalent JavaScript using:
1. Existing JavaScript features
2. More complex JS code
â¤There's no magic
â¤You write simple code in TypeScript -> gets converted into complex JS code.

TypeScript is strongly typed, whereas Javascript is dynamically typed.


ğŸ“˜ TypeScript Installation & Setup
####################################

ğŸ”¹ Compile TypeScript Code
Open terminal in the project folder.

Run the compiler: tsc app.ts
This generates app.js.

ğŸ“˜ TypeScript â€“ Variables
##########################
â¤A variable is a named storage where we can store a value.

ğŸ”¹ Creating Variables in TypeScript
Variables can be created using let or const keywords.

let num=100;
const str="hello world";

ğŸ”¹ let vs const
| Feature                 | `let`                      | `const`                               |
| ----------------------- | -------------------------- | ------------------------------------- |
| Initialization Required | âŒ Not required immediately | âœ… Must be initialized immediately     |
| Can Reassign Value      | âœ… Yes                      | âŒ No, value cannot be changed         |
| Example (Valid)         | `let x; x = 10;`           | `const y = 5;`                        |
| Example (Invalid)       | â€“                          | `const y;` (âŒ Error: must initialize) |

ğŸ”¹ Type Inference in TypeScript
################################
TypeScript automatically infers the type at the time of initialization.

Example:
let num=100; //inferred as number

Once the type is set, it cannot be changed.
num=true // âŒ Error: boolean not assignable to number

ğŸ”¹ Rules for Naming Variables
1. Allowed characters- Letters, digits, _(underscore), {dollar sign}
2. Cannot start with a digit.
3. Valid start characters: A letter, _, $
4. Case Sensitive
5. Reserved Keywords not Allowed

ğŸ“˜ Datatypes in TypeScript
############################

Note: 
â¤With Backticks we can write multi line string, not possible normally also allows expression interpolation.
â¤TypeScript numbers are always floating point numbers even if we don't see or write it.

Common Data TypeScript
string: Textual data or a sequence of characters.

number: All numeric values(both integers and float).
boolean: true or false

0, null, undefined is a falsy values.

ğŸ“˜ Explicit Typing & Type Inference

1. Explicit Typing: You can explicitly specify data types for:
â¤ Function parameters
â¤ Variables
â¤ Function return value(optional)

function sum(num1:number,num2:number):number{
    return num1+num2;
}
If non-number values are passed, TypeScript gives a compile-time error.

ğŸ”¹ 2. Without Explicit Types
If no type is specified, any type can be passed, which can lead to unexpected results.

function sum(num1,num2){
    return num1+num2;
}

sum("12",13); //Output: "1213" (string concatenation!)

ğŸ”¹ 3. Explicit Types for Variables
let n1:number=10;
let msg:string= "Result is"

ğŸ”¹ 4. Type Inference
TypeScript automatically infers the type of a variable when you assign a value during declaration.

let n1=10; //inferred as number
let name= "Ankur" //inferred as string

After inference, the type cannot be changed
n1= "Hello" //âŒ Error: string not assignable to number

ğŸ”¹ 5. Type Inference in Functions
If you define parameters without types, any value can be passed (not recommended).
â¤ Always use explicit typing in function parameters for safety.

ğŸ”¹ 6. Comparison with JavaScript
| Feature              | JavaScript          | TypeScript               |
| -------------------- | ------------------- | ------------------------ |
| Typing               | Dynamic             | Static (strong typing)   |
| Type Errors          | Detected at runtime | Detected at compile time |
| Variable Type Change | Allowed             | Not Allowed              |

ğŸ“˜ Objects in TypeScript
##########################

ğŸ”¹ 1. Creating Objects in TypeScript

let person={
    name:"John",
    age:30
};
Just like JavaScript- Key value pairs

ğŸ”¹ 2. Type Inference for Objects
â¤TypeScript infers the structure of the object at initialization.
â¤If you reassign an object with extra or missing properties, it throws an error.

person={
    name:"Mark",
    age:32,
    gender:"male" //âŒ Error: gender is not expected
};

ğŸ”¹ 3. Explicit Object Typing
let person: {name:string,age:number}={
    name:'John",
    age:30
}
Only objects matching this structure can be assigned.

ğŸ”¹ 4. Assigning object as a Type (Generic)
let person: object;

Accepts any object, but accessing specific properties will give error(TypeScript doesnâ€™t know what properties exist).

ğŸ”¹ 5. Accessing Properties
console.log(person.name); // if name exist
console.log(person["age"]); // square bracket notation

ğŸ”¹ 6. Nested Object Typing
let person:{
    name:string;
    age:number;
    address:{
        city: string;
        country: string;
    }
}={
    name:"John",
    age:30,
    address:{
        city:"London",
        country:"UK"
    }
};

ğŸ”¹ 7. JavaScript vs TypeScript
| Feature                | JavaScript      | TypeScript           |
| ---------------------- | --------------- | -------------------- |
| Type Safety            | âŒ No            | âœ… Yes                |
| Extra Property Check   | âŒ Allowed       | âœ… Error              |
| Property Inference     | âŒ Not available | âœ… Strong inference   |
| Accessing Missing Keys | `undefined`     | âŒ Compile-time error |

ğŸ“˜ Arrays in TypeScript
##########################
â¤Just like JavaScript, an array is a collection of values.
â¤Syntax to create an array is the same [], but TypeScript adds type safety.

ğŸ”¹ 1. Type Inference in Arrays
let person=["John",28,"male",1000];

TypeScript infers: (string | number)[] -> An array of string or number.

ğŸ”¹ 2. Restriction Based on Inferred Type
person.push(true);// âŒ Error: boolean not allowed
person.push(500);// number allowed

ğŸ”¹ 3. Arrays with Single Type
let names= ["Alice", "Bob"] // string[]
Push any value not matching the type -> âŒ Error

ğŸ”¹ 4. Explicitly Typing Arrays
let names: string[] = [];           // only strings allowed
names.push("John");                 // âœ… OK
names.push(42);                     // âŒ Error

//Use | (pipe) operator for multiple allowed types:
let person: (string | number)[] = ["John", 28]; // âœ…
person.push(true); // âŒ Error if boolean not included

Accessing of elements we use traditional indexing method

Use for...of loop:
for(let year of birthYears){
    console.log(year);
}

ğŸ“Œ Key Differences from JavaScript
| Feature                   | JavaScript       | TypeScript           |
| ------------------------- | ---------------- | -------------------- |
| Type Safety               | âŒ No             | âœ… Yes                |
| Invalid Type Insertion    | Allowed          | âŒ Compile-time error |
| Explicit Type Declaration | âŒ Not applicable | âœ… Supported          |
| Code Autocompletion       | Limited          | âœ… Strong support     |

ğŸ”· What is a Tuple in TypeScript?
###################################
â¤A Tuple is a fixed length, ordered collection of elements.
â¤Each position in the tuple has a specific data type.
â¤Not available in JavaScript, but compiled to an array in JS.

let employee:[number,string,number,boolean];
employee=[1123,"John", 2000,true];
â¤We cannot add 5th element but there is an exception

â— Exception: Push Method
Even though tuples are fixed-length, you can still push values to them without error:

employee.push(100): //âœ…No compiler error
This is a TypeScript limitation, not enforced at runtime or by push.

âŒ Common Errors
â¤Assigning more/fewer values than defined:

employee = [1, "Mark", 1200];     // âŒ Error: needs 4 elements
employee = [1, "Mark", 1200, true, 100]; // âŒ Error: too many elements

â¤Assigning wrong types:

employee = ["one", "John", 2000, true]; // âŒ Error: "one" is not a number

ğŸš« Why Not Use Tuples for Random, Long, Mixed Data?
Because:
â¤Tuples are meant for structure (e.g., [id, name, active])
â¤Not meant for arbitrary or unpredictable values

Tuples can be reassinged when it have same type of elements in the ordered manner in fixed defined length.

ğŸ”¶ TypeScript enum
######################

â¤A special data type used to define a set of named constants.
â¤Not available in plain JavaScript, only in TypeScript.
â¤Used for cleaner, more readable code especially when dealing with fixed categories(e.g. user roles,states);

enum Roles{
    Admin,
    ReadOnly,
    WriteOnly,
    ReadWrite
}
By default 
â¤Admin=0, ReadOnly=1,WriteOnly=2,ReadWrite=3

ğŸ§© Usage Example
let user={
    name:"Ankur",
    age:30,
    role:Roles.Admin
};

if(user.role==Roles.Admin){
    console.log("This user is Admin");
}

âœï¸ Explicit Value Assignment
Numeric:
enum Roles {
  Admin = 100,
  ReadOnly = 200,
  WriteOnly = 300,
  ReadWrite         // â†’ 301 (auto-increment from previous)
}

String:

enum Roles {
  Admin = "ADMIN",
  ReadOnly = "READ_ONLY"
}

Mixed (âš  Not recommended):

enum Roles {
  Admin = "ADMIN",
  ReadOnly = 2
}

Note:Can be mixed with string and number but initialization should end wiht number only

ğŸŒ€ Compilation to JavaScript
â¤TypeScript compiles enums to IIFE functions to generate bi-directional mappings.

âœ… When to Use Enum
â¤When you need fixed categories (roles, permissions, statuses).
â¤To avoid hardcoded strings or magic numbers in your logic.
â¤When you want autocompletion + type safety.

ğŸš« Caution
â¤Enums are not available in JS- they're a TypeScript-only feature.
Use const enum for performance(inlines the values), but it doesn't support reverse mapping.

ğŸ”¶ TypeScript any Type
#########################

â¤any is the most flexible type in TypeScript.
â¤A variable declared as any can hold any kind of value:number, string, boolean, array, object ect.
â¤Disables type checking, like JavaScript.

let data: any;

data = 42;          // âœ… No error
data = "hello";     // âœ… No error
data = true;        // âœ… No error
data = [1, 2, 3];   // âœ… No error
data = { a: 1 };    // âœ… No error

ğŸ“š any[] â€” Array of Any
let arr: any[] = [1, "two", true, null, undefined];

âš ï¸ Why to Avoid any
â¤Removes all the benifits of TypeScript.
â¤Turns TypeScript code into JavaScript-like untyped code.
â¤May lead to runtime bugs since type saftey is lost.

âœ… Use Case
â¤When you don't know the type in advance(e.g. external libraries, user inputs, JSON, parsing).
â¤Type is dynamic or varies at runtime.

ğŸ•µï¸ Variable with No Type or Value
let test;  // No value, no type
console.log(typeof test);  // "undefined"
console.log(test);         // undefined

â¤TypeScript infers test as any if used without initialization.
â¤Both type and value will be undefined.

ğŸŸ£ TypeScript: Union Types
############################
â¤A Union Type allows a variable, parameter or return type to hold more than one type.

let data: string|number; ( | ) know as pipe operator
Here data can hold either a string or a number.

âœ… Example 1: Union in Variables
let user:{name:string,age:number} | null;

âœ… Example 2: Union in Function Parameters
function printStatus(message:string,code:string|number){
    if(typeof code==="string"){ //here typeof is a type guard
        code =code.trim(); //âœ…Safe: Only used if code is string
    }
    console.log(`${message}- Status Code: ${code}`);
}
â¤To access type-specific methods, you need type guards (typeof, instanceof, etc.).

printStatus("Success",200);
printStatus("Not found","404");

â—Common Pitfall
â¤Trying to call methods that only exist on one of the types:
code.trim(); // âŒ Error: 'trim' might not exist on type 'number'

âœ”ï¸ Fix:
Use a type check:

if (typeof code === "string") {
  code = code.trim();
}

âœ… When to Use Union Types
â¤When you expect multiple possible input types.
â¤When a variable can be nullable.
â¤For flexibility with controlled safety (better than any).

ğŸŸ¡ TypeScript: Literal Types
##############################

A literal type allows you to restrict a variable to a specific value, not just a general type.

â¤Unlike string,which accepts any string value, a literal type like "admin" only accepts that exact value

âœ… Example 1: Literal Type in a Constant
const status="hello world";

â¤TypeScript infers:
status:"hello world"(Literal Type)
â¤Not just string -- it's exactly "hello world".

ğŸ†š Difference Between const and let

const msg = "hi";       // msg: "hi" (literal)
let msg2 = "hi";        // msg2: string

âœ… Example 2: Literal Types in Function Parameters
function roleMessage(role:"admin" | "read" | "read-write"){
    switch(role){
        case "admin":
        console.log("You have admin permissions");
        break;
        case "read":
        console.log("You have read permissions");
        break;
        case "read-write":
        console.log("You have read-write permissions");
        break;
        default:
        console.log("Unknown role");
    }
}

roleMessage("admin");         // âœ… allowed
roleMessage("read-write");    // âœ… allowed
roleMessage("guest");         // âŒ error at compile time

ğŸ” Literal Types Can Be:
Strings: "start" | "stop"
Numbers: 1 | 2 | 3
Booleans: true | false
Null / Undefined: null | undefined

âš ï¸ Why Use Literal Types?
â¤Adds strict control over allowed values.
â¤Prevents invalid inputs at compile time.
â¤Helps in writing safe and predictable code (especially with switch, API requests, enums, etc.).

ğŸŸ¡ TypeScript: Type Alias
##########################

â¤A Type Alias allows you to give a custom name to a type(primitive, union, literal, object etc).
â¤It helps in writing clean, reusable, and maintainable code by avoiding type repition.

âœ… Syntax
type CustomTypeName = existingType;

âœ… Example 1: Alias for a Primitive Type

type StringType=string;
let message:StringType="Hello World!";
StringType is now a custom alias for string.

âœ… Example 2: Alias for a Union Type
type StringOrNumber= string | number;

function printCode(code: StringOrNumber) {
  console.log(code);
}
â¤Instead of repeating string | number, you can use the alias StringOrNumber.

âœ… Example 3: Alias for an Object Type
type User={
    firstName:string;
    lastName:string;
    age:number;
};

function getFullName(user:User):string{
    return `${user.firstName} ${user.lastName}`;
}

ğŸ§  Bonus Tip:
You can even alias complex types like:

type UserList = User[];
type Callback = (value: number) => void;

ğŸŸ¡ TypeScript: Function Return Types
#####################################

â¤The return type of a function indicates the type of value that function will return.
â¤You can either:
Let TypeScript infer the return type automatically.
Explicitly define the return type using :type Syntax

âœ… Syntax

function functionName(params): returnType {
  // logic
  return value;
}

ğŸ”¹ Examples

1ï¸âƒ£ Function That Returns a Value

function add(num1:number,num2:number):number{
    return num1+num2;
}
â¤Return type is explicitly declared as numbers
â¤TypeScript can also infer this if return type is not specified.

2ï¸âƒ£ Incorrect Return Type

function add(num1: number, num2: number): string {
  return num1 + num2; // âŒ Error: number is not assignable to string
}

3ï¸âƒ£ Return Type Inferred as string

function add(num1: number, num2: number) {
  return (num1 + num2).toString();
}

4ï¸âƒ£ Function That Returns Nothing

function add(num1: number, num2: number): void {
  console.log(num1 + num2);
}
â¤void means that function doesn't return anything.
â¤Even if you use return; without a value, it is still void.

5ï¸âƒ£ Return Type as undefined (Not Recommended)

function add(num1: number, num2: number): undefined {
  console.log(num1 + num2);
  return undefined;
}
Works, but not recommended.
âœ… Prefer void over undefined for clarity and convention.

â¤If no return statment is used, TypeScript infers return type as void.